---
title: "Integrate all results"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: true
    toc_depth: 3
    number_sections: false
    theme: lumen
    code_folding: show
---

# Background

This analysis combines all aspects of our project. We can query proteins of interest and evaluate their prognostic association with OS in mCRPC, plasma-tissue expression concordance, druggability status, and cross-reference against previously published prostate cancer biomarkers. We also generate CPPS, stratify by median risk, and compare model performance.

# Objectives

1. Load all required data
2. Example workflows

---

# Pre-processing

## Load packages

```{r setup, message=FALSE, warning=FALSE}
library(here)
library(tidyverse)
library(readxl)
library(patchwork)
library(preprocessCore)
library(survival)
library(timeROC)
library(ComplexHeatmap)
library(circlize)
library(grid)

# Set default theme
theme_set(theme_bw())
```

## Set up directories

```{r directories}
wd <- list()
wd$main <- here()
wd$data <- file.path(wd$main, "data")
wd$public <- file.path(wd$data, "public")
wd$output <- file.path(wd$main, "output")
wd$outData <- file.path(wd$output, "data")
wd$out06 <- file.path(wd$output, "06_mCRPC_analysis")
wd$out09 <- file.path(wd$output, "09_public")
wd$outCurr <- file.path(wd$output, "10_integration")

# Create output directory if it doesn't exist
if (!file.exists(wd$outCurr)) {
  dir.create(wd$outCurr, recursive = TRUE)
  cat("✓ Created output directory:", wd$outCurr, "\n")
} else {
  cat("✓ Output directory exists:", wd$outCurr, "\n")
}
```

---

# Obj 1: Load data

The dataset required for this analysis are ;

- Previous prostate biomarker records
- Annotated protein-drug targets
- Annotated cell-surface proteins
- mCRPC overexpressed DEPs
- Olink (plasma) NPX matrix + metadata
- Tissue (Mass-spect) matrix + metadata

We also need to load the expression matrix proteomics data (public, mass-spec tissue) and our Olink (plamsa) matrix.

Finally, we need to clinical metadata file

Lets load the individual data from all previous sessions

## Expression data

Lets read in the public data with their metadata

```{r}
# Public SWATH-MS data (same source used in script 09)
public_raw <- read_excel(
  file.path(wd$public, "41467_2018_3573_MOESM4_ESM.xlsx"),
  sheet = "Area - proteins"
)
public_meta <- readr::read_csv(
  file.path(wd$public, "sample_metadata.csv"),
  show_col_types = FALSE
)

# Average technical replicates to biological sample level
public_long <- public_raw %>%
  pivot_longer(cols = -Protein, names_to = "Sample_Name", values_to = "Intensity") %>%
  left_join(public_meta, by = "Sample_Name")
public_avg <- public_long %>%
  group_by(Protein, Biological_ID, Group, Group_Number) %>%
  summarise(Intensity_Avg = mean(Intensity, na.rm = TRUE), .groups = "drop")

# Log2 + quantile normalization
public_wide <- public_avg %>%
  pivot_wider(id_cols = Protein, names_from = Biological_ID, values_from = Intensity_Avg)
public_matrix <- public_wide %>% select(-Protein) %>% as.matrix()
public_log2 <- log2(public_matrix + 1)
public_norm <- preprocessCore::normalize.quantiles(public_log2)
colnames(public_norm) <- colnames(public_log2)
rownames(public_norm) <- public_wide$Protein

cat("Public data loaded:", nrow(public_norm), "proteins x", ncol(public_norm), "samples\n")
```

Lets read in the Olink (plasma data) with their metadata

```{r}
# Olink expression (all cohorts) and metadata
olink_expr <- readr::read_csv(
  file.path(wd$outData, "allSamples_expression_matrix.csv"),
  show_col_types = FALSE
)
colnames(olink_expr)[1] <- "OlinkID"

olink_meta <- readr::read_csv(
  file.path(wd$outData, "allSamples_metadata.csv"),
  show_col_types = FALSE
)

# Clinical metadata for survival variables (requested: use OS from this file)
meta2_olink <- read.csv(file.path(wd$outData, "proteomics_metadata.csv"))
meta2_olink <- meta2_olink %>%
  mutate(
    psa_num = readr::parse_number(as.character(psa), na = c("", "NA", "N/A", "n/a", "N/a")),
    alk_phos_num = readr::parse_number(as.character(alk_phos), na = c("", "NA", "N/A", "n/a", "N/a")),
    hemoGlo_num = readr::parse_number(as.character(hemoGlo), na = c("", "NA", "N/A", "n/a", "N/a"))
  ) %>%
  mutate(
    HCI_cID = paste0("c_", gsub("-", "_", HCI_cID)),
    death = ifelse(tolower(death_status) == "y", 1, 0),
    log10_psa = log10(psa_num + 0.1),
    log10_alp = log10(alk_phos_num),
    log10_ldh = log10(hemoGlo_num)
  ) %>%
  select(-psa_num, -alk_phos_num, -hemoGlo_num)

# Curated mCRPC cohort C clinical data (used for CPPS objective)
meta_mcrpc <- read.csv(file.path(wd$outData, "mCRPC_metadata.csv")) %>%
  mutate(
    log10_psa = log10(psa + 0.1),
    log10_alp = log10(alk_phos),
    log10_ldh = log10(ldh)
  )

# Olink long format
df_npx_long <- olink_expr %>%
  pivot_longer(-OlinkID, names_to = "HCI_cID", values_to = "NPX") %>%
  left_join(
    olink_meta %>% select(HCI_cID, cohort, txt_stat_ordered),
    by = "HCI_cID"
  )

# Cohort C pre-treatment subset for CPPS prognostic modeling
df_npx_long_c_pre <- df_npx_long %>%
  filter(cohort == "C", grepl("^Pre", txt_stat_ordered))

meta_in <- meta_mcrpc %>% rename(sample_id = HCI_cID)

cat("Olink data loaded:", n_distinct(df_npx_long$OlinkID), "proteins\n")
```


The matching protein IDs from public and our Data

```{r}
matched_proteins <- readr::read_csv(
  file.path(wd$out09, "Matched_Olink_SWATHMS_Proteins.csv"),
  show_col_types = FALSE
)

matched_olink_ids <- unique(matched_proteins$OlinkID)
matched_public_ids <- unique(matched_proteins$Protein)

# Public matrix restricted to matched proteins
public_norm_matched <- public_norm[rownames(public_norm) %in% matched_public_ids, , drop = FALSE]

cat("Matched proteins:", nrow(matched_proteins), "\n")
```


## Biomarker records

Previous prostate biomarkers records

```{r}
# Read the protein biomarker table
protein_table <- read_excel(file.path(wd$data, "updated_2024/Protein biomarker pubs mCRPC_zaki_edit.xlsx"))

# Use Edited_name column for protein names (cleaner version)
protein_markers_col <- protein_table$`Edited_name`
# Function to parse sample-type-specific proteins
# Handles formats like "Tissue-based (DST, COL3A1) Urine-based (COL1A1, COL3A1)"
parse_proteins_with_sample_type <- function(markers_text, study_index) {
  proteins_list <- list()

  if (is.na(markers_text) || markers_text == "") {
    return(proteins_list)
  }

  # Check if the text contains sample type markers
  has_tissue <- grepl("Tissue-based\\s*\\(", markers_text, ignore.case = TRUE)
  has_plasma <- grepl("Plasma-based\\s*\\(", markers_text, ignore.case = TRUE)
  has_urine <- grepl("Urine-based\\s*\\(", markers_text, ignore.case = TRUE)

  if (has_tissue || has_plasma || has_urine) {
    # Parse each sample type separately

    # Extract Tissue-based proteins
    if (has_tissue) {
      tissue_match <- regmatches(markers_text, gregexpr("Tissue-based\\s*\\(([^)]+)\\)", markers_text, ignore.case = TRUE, perl = TRUE))[[1]]
      if (length(tissue_match) > 0) {
        tissue_proteins <- gsub(".*\\(([^)]+)\\).*", "\\1", tissue_match)
        tissue_proteins <- unlist(strsplit(tissue_proteins, ",\\s*"))
        tissue_proteins <- trimws(tissue_proteins)
        tissue_proteins <- gsub("^and\\s+", "", tissue_proteins, ignore.case = TRUE)
        tissue_proteins <- trimws(tissue_proteins)
        tissue_proteins <- tissue_proteins[tissue_proteins != ""]

        for (p in tissue_proteins) {
          proteins_list[[length(proteins_list) + 1]] <- list(name = p, sample_type = "Tissue")
        }
      }
    }

    # Extract Plasma-based proteins
    if (has_plasma) {
      plasma_match <- regmatches(markers_text, gregexpr("Plasma-based\\s*\\(([^)]+)\\)", markers_text, ignore.case = TRUE, perl = TRUE))[[1]]
      if (length(plasma_match) > 0) {
        plasma_proteins <- gsub(".*\\(([^)]+)\\).*", "\\1", plasma_match)
        plasma_proteins <- unlist(strsplit(plasma_proteins, ",\\s*"))
        plasma_proteins <- trimws(plasma_proteins)
        plasma_proteins <- gsub("^and\\s+", "", plasma_proteins, ignore.case = TRUE)
        plasma_proteins <- trimws(plasma_proteins)
        plasma_proteins <- plasma_proteins[plasma_proteins != ""]

        for (p in plasma_proteins) {
          proteins_list[[length(proteins_list) + 1]] <- list(name = p, sample_type = "Plasma")
        }
      }
    }

    # Extract Urine-based proteins
    if (has_urine) {
      urine_match <- regmatches(markers_text, gregexpr("Urine-based\\s*\\(([^)]+)\\)", markers_text, ignore.case = TRUE, perl = TRUE))[[1]]
      if (length(urine_match) > 0) {
        urine_proteins <- gsub(".*\\(([^)]+)\\).*", "\\1", urine_match)
        urine_proteins <- unlist(strsplit(urine_proteins, ",\\s*"))
        urine_proteins <- trimws(urine_proteins)
        urine_proteins <- gsub("^and\\s+", "", urine_proteins, ignore.case = TRUE)
        urine_proteins <- trimws(urine_proteins)
        urine_proteins <- urine_proteins[urine_proteins != ""]

        for (p in urine_proteins) {
          proteins_list[[length(proteins_list) + 1]] <- list(name = p, sample_type = "Urine")
        }
      }
    }
  } else {
    # No sample type specified - parse normally
    proteins <- unlist(strsplit(markers_text, ",\\s*"))
    proteins <- trimws(proteins)
    proteins <- gsub("^and\\s+", "", proteins, ignore.case = TRUE)
    proteins <- trimws(proteins)
    proteins <- proteins[proteins != ""]

    for (p in proteins) {
      proteins_list[[length(proteins_list) + 1]] <- list(name = p, sample_type = NA)
    }
  }

  return(proteins_list)
}

# Extract all proteins with their sample types
all_protein_entries <- list()
for (i in 1:nrow(protein_table)) {
  markers <- protein_markers_col[i]
  proteins_in_study <- parse_proteins_with_sample_type(markers, i)
  all_protein_entries[[i]] <- proteins_in_study
}

# Create unique protein identifiers
# Just use protein names without sample type suffix
all_proteins_raw <- lapply(all_protein_entries, function(study) {
  sapply(study, function(p) p$name)
}) %>% unlist()


biom_unique_proteins <- sort(unique(all_proteins_raw))
```

## Annotated protein-drug target

Lets read in the whole database 


```{r}
# Downloaded the file from DrugBank
df_target <- read.csv(file.path(wd$data, "DrugBank/drugbank_all_target_polypeptide_ids.csv/pharmacologically_active.csv"))
df_vocab <- read.csv(file.path(wd$data, "DrugBank/drugbank vocabulary.csv"))
```

Manual addition of drug targets

```{r}
df_target_manual <- read.delim(file.path(wd$data, "Drug_review/protein_drug_associations.tsv"),
                               sep = "\t", 
                               stringsAsFactors = FALSE)
```

Get a final list combining both

```{r}
df_target_sub <- df_target %>% select(Gene.Name, Drug.IDs) %>% 
  mutate(Drug.IDs = str_split(Drug.IDs, ",\\s*")) %>%
  tidyr::unnest(Drug.IDs) %>%
  filter(!is.na(Gene.Name), !is.na(Drug.IDs), Drug.IDs != "") %>%
  distinct(Gene.Name, Drug.IDs) %>%
  group_by(Gene.Name) %>%
  summarise(
    DrugBank.ID = str_c(sort(unique(Drug.IDs)), collapse = "; "),
    .groups = "drop"
  )
```

Replace DrugID with common name

```{r}
df_vocab_sub <- df_vocab %>% select(DrugBank.ID, Common.name)
# Replace each DrugBank ID with the corresponding Common name
df_target_ann <- df_target_sub %>%
  mutate(
    DrugBank.ID_list = str_split(DrugBank.ID, ";\\s*"),
    drugname = purrr::map_chr(DrugBank.ID_list, function(ids) {
      names <- df_vocab_sub %>%
        filter(DrugBank.ID %in% ids) %>%
        pull(Common.name) %>%
        unique()
      str_c(names, collapse = "; ")
    })
  ) %>%
  select(-DrugBank.ID_list)
```


We include additional annotations of drug that was done through manual curations

```{r}
# Proteins that are drug target from manual curations
dt_manual <- df_target_manual %>% filter(Drug_Association == "Yes") %>% pull (Protein)

# Final unique list of proteins considered drug-annotated (DrugBank + manual)
drug_annotated_proteins <- sort(unique(c(
  df_target_ann %>% filter(!is.na(DrugBank.ID), DrugBank.ID != "") %>% pull(Gene.Name),
  dt_manual
)))

df_druggable_index <- tibble(
  Protein = drug_annotated_proteins,
  is_Dx = "Yes"
)

cat("Drug-annotated unique proteins:", length(drug_annotated_proteins), "\n")
```

## Annotated cell-surface proteins

```{r}
# List of cell surface markers
cs <- read.delim(file.path(wd$outData, "CS_human.txt"))
cs_prot <- unique(cs$Approved.symbol)
```


## mCRPC DEPs

The mCRPC DEP are genes considered over-expressed in mCRPc

```{r}
df_DEPs <- read.csv(file.path(wd$out06, "HR_values_mCRPC_specific_multivariate_cell_surface.csv"))

# Section 03 all-protein multivariate HR results (2000+ proteins)
df_hr_all <- read.csv(file.path(wd$out06, "HR_values_mCRPC_specific_multi_pre-allProteins.csv"))
df_hr_all <- df_hr_all %>%
  filter(!is.na(Assay), Assay != "") %>%
  distinct(OlinkID, Assay, .keep_all = TRUE)

# Considered prognostic
prog_prot <- df_DEPs %>% filter(Multi_Sig == "Yes") %>% pull(Assay) %>% unique()
```



# Objective 2: Calculate CPPS from any proteins

We want to calculate CPPS from any protein combination, including proteins without pre-existing multivariate coefficients.


The workflow below supports both univariate and multivariate coefficient options (plus equal-weight fallback).

```{r}
cat("=== Objective 2: CPPS from user-defined protein sets ===\n")

# De-duplicate Assay symbols once (pick one row for duplicated assays)
dep_unique <- df_DEPs %>%
  arrange(Multi_FDR_num, desc(abs(Multi_Coefficient))) %>%
  distinct(Assay, .keep_all = TRUE)

prepare_cpps_protein_table <- function(proteins, method = c("multivariate", "univariate", "equal_weight")) {
  method <- match.arg(method)

  pt <- tibble(Assay = proteins) %>%
    left_join(
      dep_unique %>% select(Assay, OlinkID, Uni_Coefficient, Multi_Coefficient),
      by = "Assay"
    )

  if (method == "multivariate") {
    pt <- pt %>% mutate(Coefficient = Multi_Coefficient)
  } else if (method == "univariate") {
    pt <- pt %>% mutate(Coefficient = Uni_Coefficient)
  } else {
    pt <- pt %>% mutate(Coefficient = 1)
  }

  # Allow proteins without published coefficients by assigning unit weight
  pt <- pt %>%
    mutate(Coefficient = ifelse(is.na(Coefficient), 1, Coefficient)) %>%
    filter(!is.na(OlinkID)) %>%
    distinct(OlinkID, .keep_all = TRUE)

  pt
}

build_cpps_dataset <- function(protein_table) {
  cpps_scores <- df_npx_long_c_pre %>%
    filter(OlinkID %in% protein_table$OlinkID) %>%
    select(HCI_cID, OlinkID, NPX) %>%
    left_join(protein_table %>% select(OlinkID, Coefficient), by = "OlinkID") %>%
    group_by(HCI_cID) %>%
    summarise(CPPS = sum(Coefficient * NPX, na.rm = TRUE), .groups = "drop")

  df_cpps <- meta_mcrpc %>%
    inner_join(cpps_scores, by = "HCI_cID") %>%
    transmute(
      SampleID = HCI_cID,
      CPPS = CPPS,
      log10_psa = log10_psa,
      log10_alp = log10_alp,
      log10_ldh = log10_ldh,
      time_to_death = OS,
      death = death
    ) %>%
    filter(!is.na(CPPS), !is.na(time_to_death), !is.na(death))

  cpps_cut <- median(df_cpps$CPPS, na.rm = TRUE)
  df_cpps %>%
    mutate(
      CPPS_risk = ifelse(CPPS >= cpps_cut, "High", "Low"),
      CPPS_risk = factor(CPPS_risk, levels = c("Low", "High"))
    )
}

run_cpps_model <- function(df_cpps, model_type = c("CPPS_only", "Clinical_plus_CPPS"), eval_times = c(24, 36)) {
  model_type <- match.arg(model_type)
  df_cpps_complete <- df_cpps %>%
    filter(!is.na(log10_psa), !is.na(log10_alp), !is.na(log10_ldh))

  if (model_type == "CPPS_only") {
    fit <- coxph(Surv(time_to_death, death) ~ CPPS, data = df_cpps_complete)
  } else {
    fit <- coxph(Surv(time_to_death, death) ~ log10_psa + log10_alp + log10_ldh + CPPS, data = df_cpps_complete)
  }

  fit_bin <- coxph(Surv(time_to_death, death) ~ CPPS_risk, data = df_cpps_complete)
  lp <- predict(fit, type = "lp")

  roc_obj <- timeROC(
    T = df_cpps_complete$time_to_death,
    delta = df_cpps_complete$death,
    marker = lp,
    cause = 1,
    times = eval_times,
    iid = TRUE
  )
  auc_vals <- if (length(roc_obj$AUC) == length(eval_times) + 1) roc_obj$AUC[2:(length(eval_times) + 1)] else roc_obj$AUC[1:length(eval_times)]

  fit_summary <- summary(fit)
  fit_bin_summary <- summary(fit_bin)

  tibble(
    Model = model_type,
    N = nrow(df_cpps_complete),
    Events = sum(df_cpps_complete$death),
    HR_CPPS_cont = fit_summary$conf.int[nrow(fit_summary$conf.int), "exp(coef)"],
    HR_CPPS_cont_L95 = fit_summary$conf.int[nrow(fit_summary$conf.int), "lower .95"],
    HR_CPPS_cont_U95 = fit_summary$conf.int[nrow(fit_summary$conf.int), "upper .95"],
    P_CPPS_cont = fit_summary$coefficients[nrow(fit_summary$coefficients), "Pr(>|z|)"],
    HR_High_vs_Low = fit_bin_summary$conf.int[1, "exp(coef)"],
    HR_High_vs_Low_L95 = fit_bin_summary$conf.int[1, "lower .95"],
    HR_High_vs_Low_U95 = fit_bin_summary$conf.int[1, "upper .95"],
    P_High_vs_Low = fit_bin_summary$coefficients[1, "Pr(>|z|)"],
    AUC_24m = round(auc_vals[1], 3),
    AUC_36m = round(auc_vals[2], 3)
  )
}

# Example run
example_proteins <- dep_unique %>%
  filter(Multi_Sig == "Yes") %>%
  arrange(desc(Multi_HR)) %>%
  slice_head(n = 10) %>%
  pull(Assay)

cpps_protein_table <- prepare_cpps_protein_table(example_proteins, method = "multivariate")
df_cpps_example <- build_cpps_dataset(cpps_protein_table)
cpps_perf_cpps <- run_cpps_model(df_cpps_example, model_type = "CPPS_only")
cpps_perf_combined <- run_cpps_model(df_cpps_example, model_type = "Clinical_plus_CPPS")
cpps_performance <- bind_rows(cpps_perf_cpps, cpps_perf_combined)

print(cpps_performance)
```


# Objective 3: Some plots


## HR plots

```{r}
# Map OlinkID -> Assay (pick one mapping per assay)
assay_map <- bind_rows(
  dep_unique %>% select(OlinkID, Assay),
  matched_proteins %>% select(OlinkID, Assay)
) %>%
  filter(!is.na(Assay)) %>%
  distinct(OlinkID, .keep_all = TRUE)

fit_olink_hr <- function(proteins) {
  prot_tbl <- tibble(Assay = proteins) %>%
    left_join(assay_map, by = "Assay") %>%
    filter(!is.na(OlinkID)) %>%
    distinct(Assay, .keep_all = TRUE)

  hr_df <- df_npx_long %>%
    filter(cohort == "C", grepl("^Pre", txt_stat_ordered), OlinkID %in% prot_tbl$OlinkID) %>%
    left_join(prot_tbl %>% select(OlinkID, Assay), by = "OlinkID") %>%
    left_join(meta2_olink %>% select(HCI_cID, OS, death, log10_psa, log10_ldh, log10_alp), by = "HCI_cID") %>%
    group_by(Assay, OlinkID) %>%
    group_modify(~{
      dd <- .x %>% filter(!is.na(NPX), !is.na(OS), !is.na(death), !is.na(log10_psa), !is.na(log10_ldh), !is.na(log10_alp))
      if (nrow(dd) < 15 || length(unique(dd$death)) < 2) {
        return(tibble(HR = NA_real_, Lower95 = NA_real_, Upper95 = NA_real_, Pval = NA_real_, N = nrow(dd), Events = sum(dd$death)))
      }
      fit <- coxph(Surv(OS, death) ~ NPX + log10_psa + log10_ldh + log10_alp, data = dd)
      ss <- summary(fit)
      tibble(
        HR = ss$conf.int["NPX", "exp(coef)"],
        Lower95 = ss$conf.int["NPX", "lower .95"],
        Upper95 = ss$conf.int["NPX", "upper .95"],
        Pval = ss$coefficients["NPX", "Pr(>|z|)"],
        N = nrow(dd),
        Events = sum(dd$death)
      )
    }) %>%
    ungroup() %>%
    filter(!is.na(HR))

  hr_df
}

plot_olink_hr_forest <- function(hr_df, title = "Olink HR forest plot (cohort C pre-treatment)") {
  hr_df %>%
    mutate(Assay = forcats::fct_reorder(Assay, HR)) %>%
    ggplot(aes(x = HR, y = Assay)) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
    geom_errorbarh(aes(xmin = Lower95, xmax = Upper95), height = 0.18, color = "#2C7FB8") +
    geom_point(size = 2.8, color = "#D95F0E") +
    scale_x_log10() +
    labs(title = title, x = "Hazard Ratio (log scale)", y = "Protein") +
    theme_bw()
}

# Example HR forest with top 15 significant proteins
proteins_for_hr <- dep_unique %>%
  filter(Multi_Sig == "Yes") %>%
  arrange(Multi_FDR_num) %>%
  slice_head(n = 15) %>%
  pull(Assay)

hr_olink <- fit_olink_hr(proteins_for_hr)
p_hr <- plot_olink_hr_forest(hr_olink)
print(p_hr)
ggsave(file.path(wd$outCurr, "Objective3_HR_forest_olink.pdf"), p_hr, width = 8, height = 6)
```


## Expression plot

Given any protiens, plot the expression of Local prostate cancer (cohort A in Olink). mHSPC (chort B) and mCRPC. Next to it plot the public data local PC and mCRPC.

Need to use facet_wrap becayse the scale of Olink and public is different


```{r}
plot_expression_cross_platform <- function(proteins) {
  # Define color palettes
  pal.olink <- c("Local" = "#AEC7E8",
                 "mHSPC" = "#FFBB78",
                 "mCRPC" = "#98DF8A")

  # Public data group colors (Benign, Local_PC, mCRPC)
  pal.public <- c("Benign" = "grey50",
                  "Local_PC" = "#AEC7E8",
                  "mCRPC" = "#98DF8A")

  # Olink data (A/B/C, pre-treatment)
  olink_df <- df_npx_long %>%
    filter(cohort %in% c("A", "B", "C"), grepl("^Pre", txt_stat_ordered)) %>%
    left_join(assay_map, by = "OlinkID") %>%
    filter(Assay %in% proteins) %>%
    mutate(
      Group = recode(cohort, A = "Local", B = "mHSPC", C = "mCRPC"),
      Value = NPX
    ) %>%
    select(Assay, Group, Value)

  # Public tissue data (Benign, Local_PC, mCRPC)
  public_df <- as.data.frame(public_norm) %>%
    tibble::rownames_to_column("Protein") %>%
    pivot_longer(-Protein, names_to = "Biological_ID", values_to = "Value") %>%
    left_join(
      public_avg %>% select(Biological_ID, Group) %>% distinct(),
      by = "Biological_ID"
    ) %>%
    filter(Group %in% c("Benign", "Local_PC", "mCRPC")) %>%
    left_join(matched_proteins %>% select(Protein, Assay) %>% distinct(), by = "Protein") %>%
    filter(Assay %in% proteins) %>%
    select(Assay, Group, Value)

  blank_panel <- function(title_txt) {
    ggplot() +
      annotate("text", x = 1, y = 1, label = "No data", color = "grey45", size = 3.5) +
      xlim(0.5, 1.5) + ylim(0.5, 1.5) +
      labs(title = title_txt) +
      theme_void() +
      theme(
        plot.title = element_text(hjust = 0.5, size = 10, face = "bold"),
        panel.border = element_rect(color = "grey80", fill = NA)
      )
  }

  row_plots <- lapply(proteins, function(p) {
    d_ol <- olink_df %>% filter(Assay == p)
    d_pb <- public_df %>% filter(Assay == p)

    p_ol <- if (nrow(d_ol) > 0) {
      d_ol %>%
        mutate(Group = factor(Group, levels = names(pal.olink))) %>%
        ggplot(aes(x = Group, y = Value, fill = Group)) +
        geom_boxplot(outlier.shape = NA, alpha = 0.75) +
        geom_jitter(width = 0.18, size = 0.9, alpha = 0.5) +
        scale_fill_manual(values = pal.olink, drop = FALSE) +
        labs(title = paste0(p, " | Olink"), x = NULL, y = "NPX") +
        theme_bw() +
        theme(
          axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "none",
          plot.title = element_text(size = 10, face = "bold")
        )
    } else {
      blank_panel(paste0(p, " | Olink"))
    }

    p_pb <- if (nrow(d_pb) > 0) {
      d_pb %>%
        mutate(Group = factor(Group, levels = names(pal.public))) %>%
        ggplot(aes(x = Group, y = Value, fill = Group)) +
        geom_boxplot(outlier.shape = NA, alpha = 0.75) +
        geom_jitter(width = 0.18, size = 0.9, alpha = 0.5) +
        scale_fill_manual(values = pal.public, drop = FALSE) +
        labs(title = paste0(p, " | Public"), x = NULL, y = "log2 intensity") +
        theme_bw() +
        theme(
          axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "none",
          plot.title = element_text(size = 10, face = "bold")
        )
    } else {
      blank_panel(paste0(p, " | Public"))
    }

    p_ol + p_pb + patchwork::plot_layout(ncol = 2, widths = c(1, 1))
  })

  patchwork::wrap_plots(row_plots, ncol = 1) +
    patchwork::plot_annotation(title = "Cross-platform expression by protein (Left: Olink, Right: Public)")
}

# Example expression plot with matched prognostic proteins
proteins_for_expr <- matched_proteins %>%
  filter(Assay %in% prog_prot) %>%
  distinct(Assay) %>%
  slice_head(n = 6) %>%
  pull(Assay)

p_expr <- plot_expression_cross_platform(proteins_for_expr)
print(p_expr)
ggsave(file.path(wd$outCurr, "Objective3_Expression_cross_platform.pdf"), p_expr, width = 14, height = 2.6 * length(proteins_for_expr))
```


## Complex summary heatmap

Given any protein list, generate one-row-per-protein summary with:
- detection in Olink/Public,
- druggability,
- prognostic status in Olink,
- Olink/Public mCRPC-vs-Local log2FC,
- HR (plus CPPS row in the HR panel only).

```{r}
build_complex_protein_heatmap <- function(proteins, cpps_method = c("multivariate", "univariate", "equal_weight")) {
  cpps_method <- match.arg(cpps_method)

  proteins <- unique(proteins)
  if (length(proteins) == 0) stop("No proteins provided.")

  # Allow running this chunk standalone by loading HR table on demand
  hr_all_tbl <- if (exists("df_hr_all", inherits = TRUE)) {
    get("df_hr_all", inherits = TRUE)
  } else {
    read.csv(file.path(wd$out06, "HR_values_mCRPC_specific_multi_pre-allProteins.csv")) %>%
      filter(!is.na(Assay), Assay != "") %>%
      distinct(OlinkID, Assay, .keep_all = TRUE)
  }

  # 1) Binary status columns
  olink_detected <- proteins %in% unique(assay_map$Assay)
  public_detected <- proteins %in% unique(matched_proteins$Assay)
  # Case-insensitive matching for annotation sources
  is_cell_surface <- toupper(proteins) %in% toupper(unique(cs_prot))
  is_druggable <- toupper(proteins) %in% toupper(unique(drug_annotated_proteins))
  is_prognostic <- proteins %in% unique(dep_unique$Assay[dep_unique$Multi_Sig == "Yes"])

  # 2) Olink log2FC (mCRPC - Local) using pre-treatment only
  olink_fc <- df_npx_long %>%
    filter(cohort %in% c("A", "C"), grepl("^Pre", txt_stat_ordered)) %>%
    left_join(assay_map, by = "OlinkID") %>%
    filter(!is.na(Assay), Assay %in% proteins) %>%
    group_by(Assay, cohort) %>%
    summarise(mu = mean(NPX, na.rm = TRUE), .groups = "drop") %>%
    mutate(cohort_lbl = recode(cohort, A = "Local", C = "mCRPC")) %>%
    select(-cohort) %>%
    pivot_wider(names_from = cohort_lbl, values_from = mu) %>%
    mutate(Olink_log2FC = mCRPC - Local) %>%
    select(Assay, Olink_log2FC) %>%
    group_by(Assay) %>%
    summarise(Olink_log2FC = mean(Olink_log2FC, na.rm = TRUE), .groups = "drop")

  # 3) Public log2FC (mCRPC - Local_PC), following script 09 style
  public_fc <- as.data.frame(public_norm) %>%
    tibble::rownames_to_column("Protein") %>%
    pivot_longer(-Protein, names_to = "Biological_ID", values_to = "Value") %>%
    left_join(public_avg %>% select(Biological_ID, Group) %>% distinct(), by = "Biological_ID") %>%
    filter(Group %in% c("Local_PC", "mCRPC")) %>%
    group_by(Protein, Group) %>%
    summarise(mu = mean(Value, na.rm = TRUE), .groups = "drop") %>%
    pivot_wider(names_from = Group, values_from = mu) %>%
    mutate(Public_log2FC = mCRPC - Local_PC) %>%
    select(Protein, Public_log2FC) %>%
    left_join(matched_proteins %>% select(Protein, Assay) %>% distinct(), by = "Protein") %>%
    filter(!is.na(Assay), Assay %in% proteins) %>%
    group_by(Assay) %>%
    summarise(Public_log2FC = mean(Public_log2FC, na.rm = TRUE), .groups = "drop")

  # 4) Protein-level HR from section 03 all-protein multivariate output
  hr_protein <- tibble(Assay = proteins) %>%
    mutate(Assay_key = toupper(Assay)) %>%
    left_join(
      hr_all_tbl %>%
        transmute(
          Assay_key = toupper(Assay),
          HR = as.numeric(HR),
          L95 = as.numeric(Lower_Bound),
          U95 = as.numeric(Upper_Bound)
        ),
      by = "Assay_key"
    ) %>%
    select(Assay, HR, L95, U95)

  # Keep CPPS first, order protein rows by HR (highest -> lowest), NAs at bottom
  protein_order <- tibble(Assay = proteins, input_idx = seq_along(proteins)) %>%
    left_join(hr_protein %>% select(Assay, HR), by = "Assay") %>%
    arrange(is.na(HR), desc(HR), input_idx) %>%
    pull(Assay)

  # 5) CPPS HR row (only for HR panel)
  cpps_tbl <- prepare_cpps_protein_table(proteins, method = cpps_method)
  cpps_df <- build_cpps_dataset(cpps_tbl) %>%
    filter(!is.na(CPPS), !is.na(time_to_death), !is.na(death))

  cpps_hr <- NA_real_
  cpps_l95 <- NA_real_
  cpps_u95 <- NA_real_
  if (nrow(cpps_df) >= 15 && length(unique(cpps_df$death)) > 1) {
    cpps_cut_cox <- median(cpps_df$CPPS, na.rm = TRUE)
    cpps_df <- cpps_df %>%
      mutate(
        CPPS_risk = ifelse(CPPS >= cpps_cut_cox, "High", "Low"),
        CPPS_risk = factor(CPPS_risk, levels = c("Low", "High"))
      )
    fit_cpps <- coxph(Surv(time_to_death, death) ~ CPPS_risk, data = cpps_df)
    ss_cpps <- summary(fit_cpps)
    cpps_hr <- ss_cpps$conf.int["CPPS_riskHigh", "exp(coef)"]
    cpps_l95 <- ss_cpps$conf.int["CPPS_riskHigh", "lower .95"]
    cpps_u95 <- ss_cpps$conf.int["CPPS_riskHigh", "upper .95"]
  }

  # Build row index including CPPS (top row)
  rows_all <- c("CPPS", protein_order)
  n_rows <- length(rows_all)

  # Binary matrices (protein rows always 0/1; CPPS row stays NA/blank)
  mat_detect <- matrix(NA_real_, nrow = n_rows, ncol = 2,
                       dimnames = list(rows_all, c("Olink", "Public")))
  prot_idx <- match(proteins, rows_all)
  mat_detect[prot_idx, "Olink"] <- 0
  mat_detect[prot_idx, "Public"] <- 0
  mat_detect[prot_idx, "Olink"] <- as.numeric(olink_detected)
  mat_detect[prot_idx, "Public"] <- as.numeric(public_detected)

  mat_cs <- matrix(NA_real_, nrow = n_rows, ncol = 1, dimnames = list(rows_all, "CS"))
  mat_dx <- matrix(NA_real_, nrow = n_rows, ncol = 1, dimnames = list(rows_all, "Dx"))
  mat_prog <- matrix(NA_real_, nrow = n_rows, ncol = 1, dimnames = list(rows_all, "Prog"))
  mat_cs[prot_idx, 1] <- 0
  mat_dx[prot_idx, 1] <- 0
  mat_prog[prot_idx, 1] <- 0
  mat_cs[prot_idx, 1] <- as.numeric(is_cell_surface)
  mat_dx[prot_idx, 1] <- as.numeric(is_druggable)
  mat_prog[prot_idx, 1] <- as.numeric(is_prognostic)

  # FC matrix (CPPS row blank)
  mat_fc <- matrix(NA_real_, nrow = n_rows, ncol = 2,
                   dimnames = list(rows_all, c("Olink FC", "Public FC")))
  if (nrow(olink_fc) > 0) {
    mat_fc[olink_fc$Assay, "Olink FC"] <- olink_fc$Olink_log2FC
  }
  if (nrow(public_fc) > 0) {
    mat_fc[public_fc$Assay, "Public FC"] <- public_fc$Public_log2FC
  }

  # HR vectors (include CPPS as final row)
  hr_df_all <- tibble(
    RowID = rows_all,
    HR = NA_real_,
    L95 = NA_real_,
    U95 = NA_real_
  )
  hr_df_all <- hr_df_all %>%
    left_join(hr_protein %>% rename(RowID = Assay), by = "RowID", suffix = c("", ".new")) %>%
    mutate(
      HR = coalesce(HR.new, HR),
      L95 = coalesce(L95.new, L95),
      U95 = coalesce(U95.new, U95)
    ) %>%
    select(RowID, HR, L95, U95)
  hr_df_all[hr_df_all$RowID == "CPPS", c("HR", "L95", "U95")] <- list(cpps_hr, cpps_l95, cpps_u95)

  # Color scales
  col_bin <- c("0" = "grey85", "1" = "black")
  fc_cap <- suppressWarnings(max(abs(mat_fc), na.rm = TRUE))
  if (!is.finite(fc_cap) || fc_cap <= 0) fc_cap <- 1
  col_fc <- circlize::colorRamp2(c(-fc_cap, 0, fc_cap), c("#2166AC", "white", "#B2182B"))

  # Main heatmap blocks
  ht_detect <- Heatmap(
    mat_detect,
    name = "Detected",
    col = col_bin,
    na_col = "white",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    row_names_side = "left",
    row_names_gp = gpar(fontsize = 10),
    column_names_rot = 45,
    column_names_gp = gpar(fontsize = 8),
    width = unit(c(7, 7), "mm"),
    rect_gp = gpar(col = "grey70"),
    show_heatmap_legend = FALSE
  )

  ht_cs <- Heatmap(
    mat_cs,
    name = "CS",
    col = col_bin,
    na_col = "white",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    row_names_side = "left",
    show_row_names = FALSE,
    column_names_rot = 0,
    column_names_gp = gpar(fontsize = 8),
    width = unit(10, "mm"),
    rect_gp = gpar(col = "grey50"),
    show_heatmap_legend = FALSE
  )

  ht_dx <- Heatmap(
    mat_dx,
    name = "Dx",
    col = col_bin,
    na_col = "white",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    row_names_side = "left",
    show_row_names = FALSE,
    column_names_rot = 0,
    column_names_gp = gpar(fontsize = 8),
    width = unit(10, "mm"),
    rect_gp = gpar(col = "grey50"),
    show_heatmap_legend = FALSE
  )

  ht_prog <- Heatmap(
    mat_prog,
    name = "Prog",
    col = col_bin,
    na_col = "white",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    row_names_side = "left",
    show_row_names = FALSE,
    column_names_rot = 0,
    column_names_gp = gpar(fontsize = 8),
    width = unit(12, "mm"),
    rect_gp = gpar(col = "grey70"),
    show_heatmap_legend = FALSE
  )

  # Explicit spacer to create a visible gap between column 3 and 4 blocks
  ht_spacer <- Heatmap(
    matrix(NA_real_, nrow = n_rows, ncol = 1, dimnames = list(rows_all, "")),
    col = c("0" = "white"),
    na_col = "white",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    width = unit(3.5, "mm"),
    rect_gp = gpar(col = NA),
    show_heatmap_legend = FALSE
  )

  # Thin separator to keep flag columns visually distinct
  ht_sep <- Heatmap(
    matrix(NA_real_, nrow = n_rows, ncol = 1, dimnames = list(rows_all, "")),
    col = c("0" = "white"),
    na_col = "white",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    width = unit(0.8, "mm"),
    rect_gp = gpar(col = NA),
    show_heatmap_legend = FALSE
  )

  ht_fc <- Heatmap(
    mat_fc,
    name = "log2FC",
    col = col_fc,
    na_col = "white",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    column_names_rot = 45,
    column_names_gp = gpar(fontsize = 8),
    width = unit(c(16, 16), "mm"),
    rect_gp = gpar(col = "grey80")
  )

  # Row-wise HR forest panel (log2 scale so symmetric around HR=1)
  hr_x <- log2(hr_df_all$HR)
  hr_l <- log2(hr_df_all$L95)
  hr_u <- log2(hr_df_all$U95)

  hr_anno <- rowAnnotation(
    `HR (OS)` = anno_empty(
      border = TRUE,
      width = unit(45, "mm"),
      zoom = TRUE
    ),
    annotation_name_side = "top",
    annotation_name_rot = 0
  )

  ht_all <- ht_detect + ht_spacer + ht_cs + ht_sep + ht_dx + ht_sep + ht_prog + ht_sep + ht_fc + hr_anno

  draw(ht_all,
       heatmap_legend_side = "right",
       annotation_legend_side = "right",
       column_title = "Protein integration summary")

  # Draw CI and points in HR panel viewport after layout
  decorate_annotation("HR (OS)", {
    y_pos <- rev(seq_len(n_rows)) - 0.5
    ok <- which(is.finite(hr_x) & is.finite(hr_l) & is.finite(hr_u))
    if (length(ok) > 0) {
      x_min <- min(hr_l[ok], log2(0.5), na.rm = TRUE)
      x_max <- max(hr_u[ok], log2(4), na.rm = TRUE)
    } else {
      x_min <- log2(0.5)
      x_max <- log2(4)
    }
    pad <- 0.08 * (x_max - x_min + 1e-8)
    x_lims <- c(x_min - pad, x_max + pad)

    # x-axis ticks at clinically familiar HR values
    tick_hr <- c(0.5, 1, 2, 4)
    tick_x <- log2(tick_hr)

    # baseline at HR=1
    grid.lines(
      x = unit(rep((log2(1) - x_lims[1]) / diff(x_lims), 2), "npc"),
      y = unit(c(0, 1), "npc"),
      gp = gpar(col = "grey55", lty = 2)
    )

    # CIs + points
    for (i in ok) {
      x0 <- (hr_l[i] - x_lims[1]) / diff(x_lims)
      x1 <- (hr_u[i] - x_lims[1]) / diff(x_lims)
      xp <- (hr_x[i] - x_lims[1]) / diff(x_lims)
      yp <- (y_pos[i]) / n_rows
      grid.lines(x = unit(c(x0, x1), "npc"), y = unit(c(yp, yp), "npc"), gp = gpar(col = "black", lwd = 1))
      grid.points(x = unit(xp, "npc"), y = unit(yp, "npc"), pch = 16, size = unit(2.2, "mm"))
    }

    # Tick marks and labels
    for (j in seq_along(tick_x)) {
      if (tick_x[j] < x_lims[1] || tick_x[j] > x_lims[2]) next
      tx <- (tick_x[j] - x_lims[1]) / diff(x_lims)
      grid.lines(x = unit(c(tx, tx), "npc"), y = unit(c(0, 0.02), "npc"), gp = gpar(col = "black"))
      grid.text(as.character(tick_hr[j]), x = unit(tx, "npc"), y = unit(-0.02, "npc"), gp = gpar(fontsize = 6))
    }

    # Axis title at bottom of HR panel
    grid.text("Hazard Ratio", x = unit(0.5, "npc"), y = unit(-0.08, "npc"), gp = gpar(fontsize = 7))
  })
}

# Example usage
proteins_for_complex <- c("SDC1", "EDF1", "CKAP4", "LMNB2", "LETM1", "COX5B", "HIP1R", "HMOX2", "DPY30", "WFDC2", "RCC1")
pdf(file.path(wd$outCurr, "Objective3_Complex_Integration_Heatmap.pdf"), width = 12, height = 0.35 * length(proteins_for_complex) + 3)
build_complex_protein_heatmap(proteins_for_complex, cpps_method = "multivariate")
dev.off()
```
