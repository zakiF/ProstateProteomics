---
title: "Protein biomarker heatmap"
date: "2026-01-05"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
---

# Background

Generate summary heatmap of proteins associated with prognosis/predictive in prostate cancer from protein biomarker publications.

# Pre-processing

```{r, warning=FALSE, message=FALSE}
library(tidyr)
library(ggplot2)
library(dplyr)
library(here)
library(readxl)
library(writexl)
library(patchwork)
library(gridExtra)
library(grid)
library(cowplot)
library(ComplexHeatmap)
library(circlize)
```

File paths

```{r}
wd <- list()
wd$main <- here()

wd$data <- file.path(wd$main, "data", "updated_2024")
wd$out <- file.path(wd$main, "output")

# out data (location to save future data)
wd$outData <- file.path(wd$out, "out_data")

# Current output folder for heatmaps
wd$outCurr <- file.path(wd$out, "99_Heatmap")

# Create output directory if it doesn't exist
if (!dir.exists(wd$outCurr)) {
  dir.create(wd$outCurr, recursive = TRUE)
  cat("Created output directory:", wd$outCurr, "\n")
}
```

# Data Extraction

Read the protein biomarker data

```{r}
# Read the protein biomarker table
protein_table <- read_excel(file.path(wd$data, "Protein biomarker pubs mCRPC_zaki_edit.xlsx"))

# Display column names
cat("Column names in the dataset:\n")
print(colnames(protein_table))

# Display dimensions
cat("\nDataset dimensions:\n")
cat(paste("Total studies:", nrow(protein_table), "\n"))

# Extract relevant columns
# Use Edited_name column for protein names (cleaner version)
protein_markers_col <- protein_table$`Edited_name`
focus_col <- protein_table$`Prognostic and/or Predictive focus`
predictive_col <- protein_table$`If predictive, then drug target`
sample_type_col <- protein_table$`Tissue-based or Plasma or Urine-based`
study_design_col <- protein_table$`Prospective or retrospectiv/observational or in-vitro/in-vivo study`

# Display sample type distribution
cat("\nSample type distribution:\n")
print(table(sample_type_col, useNA = "ifany"))
```

# Classify studies

```{r}
# Classify study types (Prognostic, Predictive, Both)
study_type <- character(nrow(protein_table))
study_design <- character(nrow(protein_table))

for (i in 1:nrow(protein_table)) {
  has_predictive_value <- !is.na(predictive_col[i])
  focus_text <- focus_col[i]

  # Check if both prognostic and predictive are mentioned in focus column OR if predictive column has value
  has_prognostic <- grepl("Prognostic", focus_text, ignore.case = TRUE)
  has_predictive_focus <- grepl("predictive", focus_text, ignore.case = TRUE)

  if ((has_prognostic && has_predictive_focus) || (has_prognostic && has_predictive_value)) {
    study_type[i] <- "Both"
  } else if (has_predictive_focus || has_predictive_value) {
    study_type[i] <- "Predictive"
  } else if (has_prognostic) {
    study_type[i] <- "Prognostic"
  } else {
    study_type[i] <- "Unknown"
  }

  # Extract study design (Prospective vs Retrospective)
  design_text <- study_design_col[i]
  if (grepl("Prospective", design_text, ignore.case = TRUE)) {
    study_design[i] <- "Prospective"
  } else if (grepl("Retrospective", design_text, ignore.case = TRUE)) {
    study_design[i] <- "Retrospective"
  } else {
    study_design[i] <- "Unknown"
  }
}

# Print summary of study types
cat("\n=== Study Type Distribution ===\n")
print(table(study_type))
cat("\n=== Study Design Distribution ===\n")
print(table(study_design))
```

# Extract protein names

```{r}
# Function to parse sample-type-specific proteins
# Handles formats like "Tissue-based (DST, COL3A1) Urine-based (COL1A1, COL3A1)"
parse_proteins_with_sample_type <- function(markers_text, study_index) {
  proteins_list <- list()

  if (is.na(markers_text) || markers_text == "") {
    return(proteins_list)
  }

  # Check if the text contains sample type markers
  has_tissue <- grepl("Tissue-based\\s*\\(", markers_text, ignore.case = TRUE)
  has_plasma <- grepl("Plasma-based\\s*\\(", markers_text, ignore.case = TRUE)
  has_urine <- grepl("Urine-based\\s*\\(", markers_text, ignore.case = TRUE)

  if (has_tissue || has_plasma || has_urine) {
    # Parse each sample type separately

    # Extract Tissue-based proteins
    if (has_tissue) {
      tissue_match <- regmatches(markers_text, gregexpr("Tissue-based\\s*\\(([^)]+)\\)", markers_text, ignore.case = TRUE, perl = TRUE))[[1]]
      if (length(tissue_match) > 0) {
        tissue_proteins <- gsub(".*\\(([^)]+)\\).*", "\\1", tissue_match)
        tissue_proteins <- unlist(strsplit(tissue_proteins, ",\\s*"))
        tissue_proteins <- trimws(tissue_proteins)
        tissue_proteins <- gsub("^and\\s+", "", tissue_proteins, ignore.case = TRUE)
        tissue_proteins <- trimws(tissue_proteins)
        tissue_proteins <- tissue_proteins[tissue_proteins != ""]

        for (p in tissue_proteins) {
          proteins_list[[length(proteins_list) + 1]] <- list(name = p, sample_type = "Tissue")
        }
      }
    }

    # Extract Plasma-based proteins
    if (has_plasma) {
      plasma_match <- regmatches(markers_text, gregexpr("Plasma-based\\s*\\(([^)]+)\\)", markers_text, ignore.case = TRUE, perl = TRUE))[[1]]
      if (length(plasma_match) > 0) {
        plasma_proteins <- gsub(".*\\(([^)]+)\\).*", "\\1", plasma_match)
        plasma_proteins <- unlist(strsplit(plasma_proteins, ",\\s*"))
        plasma_proteins <- trimws(plasma_proteins)
        plasma_proteins <- gsub("^and\\s+", "", plasma_proteins, ignore.case = TRUE)
        plasma_proteins <- trimws(plasma_proteins)
        plasma_proteins <- plasma_proteins[plasma_proteins != ""]

        for (p in plasma_proteins) {
          proteins_list[[length(proteins_list) + 1]] <- list(name = p, sample_type = "Plasma")
        }
      }
    }

    # Extract Urine-based proteins
    if (has_urine) {
      urine_match <- regmatches(markers_text, gregexpr("Urine-based\\s*\\(([^)]+)\\)", markers_text, ignore.case = TRUE, perl = TRUE))[[1]]
      if (length(urine_match) > 0) {
        urine_proteins <- gsub(".*\\(([^)]+)\\).*", "\\1", urine_match)
        urine_proteins <- unlist(strsplit(urine_proteins, ",\\s*"))
        urine_proteins <- trimws(urine_proteins)
        urine_proteins <- gsub("^and\\s+", "", urine_proteins, ignore.case = TRUE)
        urine_proteins <- trimws(urine_proteins)
        urine_proteins <- urine_proteins[urine_proteins != ""]

        for (p in urine_proteins) {
          proteins_list[[length(proteins_list) + 1]] <- list(name = p, sample_type = "Urine")
        }
      }
    }
  } else {
    # No sample type specified - parse normally
    proteins <- unlist(strsplit(markers_text, ",\\s*"))
    proteins <- trimws(proteins)
    proteins <- gsub("^and\\s+", "", proteins, ignore.case = TRUE)
    proteins <- trimws(proteins)
    proteins <- proteins[proteins != ""]

    for (p in proteins) {
      proteins_list[[length(proteins_list) + 1]] <- list(name = p, sample_type = NA)
    }
  }

  return(proteins_list)
}

# Extract all proteins with their sample types
all_protein_entries <- list()
for (i in 1:nrow(protein_table)) {
  markers <- protein_markers_col[i]
  proteins_in_study <- parse_proteins_with_sample_type(markers, i)
  all_protein_entries[[i]] <- proteins_in_study
}

# Create unique protein identifiers
# Just use protein names without sample type suffix
all_proteins_raw <- lapply(all_protein_entries, function(study) {
  sapply(study, function(p) p$name)
}) %>% unlist()

# Capitalize first letter of each protein name
# capitalize_first <- function(x) {
#   if (is.na(x) || x == "") return(x)
#   # Handle special cases like "sE-Cadherin" - keep lowercase s
#   # For most proteins, capitalize first letter
#   paste0(toupper(substring(x, 1, 1)), substring(x, 2))
# }

#all_proteins_raw <- sapply(all_proteins_raw, capitalize_first)

unique_proteins <- sort(unique(all_proteins_raw))

cat("\n=== Protein Extraction Summary ===\n")
cat(paste("Total unique proteins:", length(unique_proteins), "\n"))
cat("\nFirst 20 proteins:\n")
print(head(unique_proteins, 20))
```

# Create binary matrix

```{r}
# Create a binary matrix
n_studies <- nrow(protein_table)
protein_matrix <- matrix(0, nrow = length(unique_proteins), ncol = n_studies)
rownames(protein_matrix) <- unique_proteins
colnames(protein_matrix) <- 1:n_studies

# Fill in the matrix using the parsed protein entries
for (i in 1:n_studies) {
  proteins_in_study <- all_protein_entries[[i]]

  for (protein_entry in proteins_in_study) {
    # Use just the protein name (no sample type suffix)
    # Capitalize first letter to match unique_proteins
    #protein_id <- capitalize_first(protein_entry$name)
    protein_id <- protein_entry$name

    # Mark protein as present in this study
    if (protein_id %in% unique_proteins) {
      protein_matrix[protein_id, i] <- 1
    }
  }
}

cat("\n=== Matrix Summary ===\n")
cat(paste("Matrix dimensions:", nrow(protein_matrix), "proteins x", ncol(protein_matrix), "studies\n"))

# Identify proteins that appear only once
protein_counts <- rowSums(protein_matrix)
single_occurrence_proteins <- names(protein_counts)[protein_counts == 1]

cat(paste("\nProteins appearing in only one study:", length(single_occurrence_proteins), "\n"))
cat("Note: Keeping ALL proteins in the heatmap, including single-occurrence proteins\n")

# Do NOT group single occurrence proteins - keep them all
cat(paste("\nFinal matrix dimensions:", nrow(protein_matrix), "proteins x", ncol(protein_matrix), "studies\n"))
```

# Prepare data for visualization

```{r}
# Calculate percentage and study counts for each protein
protein_counts <- rowSums(protein_matrix)
protein_percentage <- (protein_counts / ncol(protein_matrix)) * 100

# Get study numbers for each protein
get_study_numbers <- function(protein_name, protein_matrix) {
  study_cols <- which(protein_matrix[protein_name, ] == 1)
  return(paste(study_cols, collapse = ", "))
}

# Create data frame for plotting
plot_data <- data.frame(
  Protein = rownames(protein_matrix),
  Count = protein_counts,
  Percentage = protein_percentage,
  StudyNumbers = sapply(rownames(protein_matrix), function(x) get_study_numbers(x, protein_matrix)),
  stringsAsFactors = FALSE
)

# Keep ALL proteins (including single occurrence)
# Order by percentage (descending), but move "Other proteins" to the bottom

# Separate "Other proteins" from the rest
other_proteins_rows <- plot_data[grepl("^Other", plot_data$Protein, ignore.case = TRUE), ]
regular_proteins <- plot_data[!grepl("^Other", plot_data$Protein, ignore.case = TRUE), ]

# Order regular proteins by percentage (descending)
regular_proteins <- regular_proteins[order(-regular_proteins$Percentage), ]

# Combine: regular proteins first, then "Other proteins" at the bottom
if (nrow(other_proteins_rows) > 0) {
  plot_data <- rbind(regular_proteins, other_proteins_rows)
} else {
  plot_data <- regular_proteins
}

# Reorder protein factor levels for plotting
plot_data$Protein <- factor(plot_data$Protein, levels = plot_data$Protein)

cat("\n=== Plotting Data Summary ===\n")
cat(paste("Number of proteins to plot:", nrow(plot_data), "\n"))
cat("\nTop 10 proteins by frequency:\n")
print(head(plot_data, 10))
cat("\nBottom 5 proteins:\n")
print(tail(plot_data, 5))
```

# Create matrix for ComplexHeatmap

```{r}
# Get all proteins (including single occurrence)
proteins_to_include <- plot_data$Protein

# Create a character matrix to store study type information
# Format: "pred" for Predictive, "prog" for Prognostic, "both" for Both
heatmap_matrix <- matrix("", nrow = length(proteins_to_include), ncol = ncol(protein_matrix))
rownames(heatmap_matrix) <- proteins_to_include
colnames(heatmap_matrix) <- colnames(protein_matrix)

# Fill the matrix with study type information
for (i in 1:nrow(heatmap_matrix)) {
  protein <- rownames(heatmap_matrix)[i]

  for (j in 1:ncol(heatmap_matrix)) {
    # Check if protein is present in this study
    if (protein_matrix[protein, j] == 1) {
      # Get the study type for this study
      study_type_j <- study_type[j]

      # Create strings based on study type
      if (study_type_j == "Both") {
        heatmap_matrix[i, j] <- "pred;prog"
      } else if (study_type_j == "Predictive") {
        heatmap_matrix[i, j] <- "pred"
      } else if (study_type_j == "Prognostic") {
        heatmap_matrix[i, j] <- "prog"
      } else {
        # Unknown - treat as prognostic
        heatmap_matrix[i, j] <- "prog"
      }
    }
  }
}

# Create ordering data frame for sorting proteins by frequency
protein_order_df <- data.frame(
  Protein = rownames(heatmap_matrix),
  Frequency = rowSums(protein_matrix[rownames(heatmap_matrix), ] > 0),
  stringsAsFactors = FALSE
)

# Separate "Other proteins" from the rest
other_proteins_heatmap <- protein_order_df[grepl("^Other", protein_order_df$Protein, ignore.case = TRUE), ]
regular_proteins_heatmap <- protein_order_df[!grepl("^Other", protein_order_df$Protein, ignore.case = TRUE), ]

# Sort regular proteins by Frequency (descending)
regular_proteins_heatmap <- regular_proteins_heatmap[order(-regular_proteins_heatmap$Frequency), ]

# Combine: regular proteins first, then "Other proteins" at the bottom
if (nrow(other_proteins_heatmap) > 0) {
  protein_order_df <- rbind(regular_proteins_heatmap, other_proteins_heatmap)
} else {
  protein_order_df <- regular_proteins_heatmap
}

# Reorder heatmap_matrix rows
heatmap_matrix <- heatmap_matrix[protein_order_df$Protein, ]

cat("\n=== Heatmap Matrix Summary ===\n")
cat(paste("Heatmap matrix dimensions:", nrow(heatmap_matrix), "x", ncol(heatmap_matrix), "\n"))
cat("\nSample values (first 5 proteins, first 5 studies):\n")
print(heatmap_matrix[1:min(5, nrow(heatmap_matrix)), 1:min(5, ncol(heatmap_matrix))])
cat("\nProtein ordering (first 10):\n")
print(head(protein_order_df, 10))
```

# Column ordering based on sample type

```{r}
# Create column ordering based on sample type
col_order_df <- data.frame(
  StudyIndex = 1:ncol(protein_matrix),
  StudyType = study_type,
  SampleType = sample_type_col,
  stringsAsFactors = FALSE
)

# Clean up sample type values
col_order_df$SampleType <- trimws(col_order_df$SampleType)

# Classify each study as Plasma, Tissue, or Urine (primary category)
col_order_df$SampleCategory <- sapply(col_order_df$SampleType, function(x) {
  if (is.na(x)) return("Unknown")
  x_lower <- tolower(x)
  # Priority order: Plasma > Tissue > Urine
  if (grepl("plasma", x_lower)) return("Plasma")
  else if (grepl("tissue", x_lower)) return("Tissue")
  else if (grepl("urine", x_lower)) return("Urine")
  else return("Other")
})

# Print sample category distribution
cat("\n=== Sample Category Distribution ===\n")
print(table(col_order_df$SampleCategory))

# Create scoring system for ordering columns
# Order by: 1) Sample type (Plasma, Tissue, Urine), 2) PSA presence, 3) ALP presence, 4) Hb presence

# Function to create protein presence score
create_protein_score <- function(protein_name, protein_matrix, study_type) {
  score <- numeric(ncol(protein_matrix))

  if (protein_name %in% rownames(protein_matrix)) {
    for (i in 1:length(score)) {
      if (protein_matrix[protein_name, i] == 1) {
        score[i] <- 1
      }
    }
  }

  return(score)
}

# Add scores for PSA, ALP, and Hb
col_order_df$PSA_score <- create_protein_score("PSA", protein_matrix, study_type)
col_order_df$ALP_score <- create_protein_score("ALP", protein_matrix, study_type)
col_order_df$Hb_score <- create_protein_score("Hb", protein_matrix, study_type)

# Add flag for studies with multiple sample types (like study 66 with Tissue + Urine)
col_order_df$MultiSampleType <- FALSE
for (i in 1:nrow(col_order_df)) {
  study_idx <- col_order_df$StudyIndex[i]
  proteins_in_study <- all_protein_entries[[study_idx]]
  sample_types_in_study <- unique(sapply(proteins_in_study, function(p) p$sample_type))
  sample_types_in_study <- sample_types_in_study[!is.na(sample_types_in_study)]

  # Mark as multi-sample if it has more than one sample type
  if (length(sample_types_in_study) > 1) {
    col_order_df$MultiSampleType[i] <- TRUE
  }
}

# Define sample category order (Plasma first, then Tissue, then Urine)
sample_category_order <- c("Plasma", "Tissue", "Urine", "Other", "Unknown")
col_order_df$SampleCategory <- factor(col_order_df$SampleCategory, levels = sample_category_order)

# Sort by: Sample category, then MultiSampleType (FALSE first, TRUE last to push multi-sample studies to end),
# then PSA (desc), then ALP (desc), then Hb (desc)
col_order_df <- col_order_df[order(col_order_df$SampleCategory,
                                     col_order_df$MultiSampleType,
                                     -col_order_df$PSA_score,
                                     -col_order_df$ALP_score,
                                     -col_order_df$Hb_score), ]

# Get the column order indices
column_order <- col_order_df$StudyIndex

cat("\n=== Column Ordering Summary ===\n")
cat("Ordered by:\n")
cat("  1. Sample type (Plasma > Tissue > Urine)\n")
cat("  2. Multi-sample studies placed at END of their category\n")
cat("  3. Within category: PSA, ALP, Hb presence\n")
cat(paste("\nStudies with multiple sample types:", sum(col_order_df$MultiSampleType), "\n"))
cat("\nFirst 15 studies in new order:\n")
print(head(col_order_df[, c("StudyIndex", "SampleCategory", "MultiSampleType", "PSA_score", "ALP_score", "Hb_score")], 15))
cat("\nLast 5 studies in new order:\n")
print(tail(col_order_df[, c("StudyIndex", "SampleCategory", "MultiSampleType", "PSA_score", "ALP_score", "Hb_score")], 5))

# Reorder heatmap_matrix columns
heatmap_matrix_ordered <- heatmap_matrix[, column_order]

# Create mapping from old study numbers to new study numbers
study_mapping <- data.frame(
  Original_Study_Number = column_order,
  New_Study_Number = 1:length(column_order),
  stringsAsFactors = FALSE
)

# Rename columns to new sequential numbers
colnames(heatmap_matrix_ordered) <- as.character(1:ncol(heatmap_matrix_ordered))
```

# Define color functions for heatmap

```{r}
# Define base colors
# Predictive = darker shade, Prognostic = lighter shade
col <- c(
  # Predictive (darker)
  pred = "#E41A1C",      # Dark red

  # Prognostic (lighter)
  prog = "#FFB3B3"       # Light red
)

# Create alter_fun list for triangular splits
alter_fun_list <- list(
  # Background shows grey when no protein present
  background = function(x, y, w, h) {
    # Bottom-left triangle
    grid.polygon(
      unit.c(x - 0.5*w, x - 0.5*w, x + 0.5*w),
      unit.c(y - 0.5*h, y + 0.5*h, y - 0.5*h),
      gp = gpar(fill = "grey95", col = "white"))
    # Top-right triangle
    grid.polygon(
      unit.c(x + 0.5*w, x + 0.5*w, x - 0.5*w),
      unit.c(y + 0.5*h, y - 0.5*h, y + 0.5*h),
      gp = gpar(fill = "grey95", col = "white"))
  },

  # Predictive (bottom-left triangle, dark red)
  pred = function(x, y, w, h) {
    grid.polygon(
      unit.c(x - 0.5*w, x - 0.5*w, x + 0.5*w),
      unit.c(y - 0.5*h, y + 0.5*h, y - 0.5*h),
      gp = gpar(fill = col["pred"], col = "white"))
  },

  # Prognostic (top-right triangle, light red)
  prog = function(x, y, w, h) {
    grid.polygon(
      unit.c(x + 0.5*w, x + 0.5*w, x - 0.5*w),
      unit.c(y + 0.5*h, y - 0.5*h, y + 0.5*h),
      gp = gpar(fill = col["prog"], col = "white"))
  }
)

cat("\n=== Color Functions Created ===\n")
print(names(alter_fun_list))
```

# Create column annotations for sample types

```{r}
# Reorder sample type data to match column ordering
# Need to check each study for multiple sample types based on the parsed protein entries
sample_types_reordered <- col_order_df$SampleType[match(column_order, col_order_df$StudyIndex)]

# Create binary vectors based on actual proteins parsed (not just the summary column)
# This will properly handle studies like #66 that have both Tissue and Urine
plasma_vec <- rep("no", length(column_order))
tissue_vec <- rep("no", length(column_order))
urine_vec <- rep("no", length(column_order))

for (i in 1:length(column_order)) {
  original_study_idx <- column_order[i]
  proteins_in_study <- all_protein_entries[[original_study_idx]]

  # Check what sample types are present in this study
  sample_types_in_study <- unique(sapply(proteins_in_study, function(p) p$sample_type))
  sample_types_in_study <- sample_types_in_study[!is.na(sample_types_in_study)]

  # If no specific sample types found, fall back to the summary column
  if (length(sample_types_in_study) == 0) {
    sample_type_text <- sample_types_reordered[i]
    if (!is.na(sample_type_text)) {
      sample_type_lower <- tolower(sample_type_text)
      if (grepl("plasma", sample_type_lower)) plasma_vec[i] <- "yes"
      if (grepl("tissue", sample_type_lower)) tissue_vec[i] <- "yes"
      if (grepl("urine", sample_type_lower)) urine_vec[i] <- "yes"
    }
  } else {
    # Mark based on parsed sample types
    if ("Plasma" %in% sample_types_in_study) plasma_vec[i] <- "yes"
    if ("Tissue" %in% sample_types_in_study) tissue_vec[i] <- "yes"
    if ("Urine" %in% sample_types_in_study) urine_vec[i] <- "yes"
  }
}

cat("\n=== Sample Type Annotation Summary ===\n")
cat(paste("Studies with Plasma:", sum(plasma_vec == "yes"), "\n"))
cat(paste("Studies with Tissue:", sum(tissue_vec == "yes"), "\n"))
cat(paste("Studies with Urine:", sum(urine_vec == "yes"), "\n"))
cat(paste("Studies with multiple sample types:", sum((plasma_vec == "yes") + (tissue_vec == "yes") + (urine_vec == "yes") > 1), "\n"))

# Define colors for sample type annotations
sample_type_colors <- c(
  "Plasma" = "#377EB8",  # Blue
  "Tissue" = "#4DAF4A",  # Green
  "Urine" = "#FF7F00"    # Orange
)

# Create column annotation showing sample types
column_ha <- HeatmapAnnotation(
  Plasma = anno_simple(plasma_vec,
                       col = c("no" = "white", "yes" = "#377EB8"),
                       height = unit(5, "mm"),
                       border = TRUE),
  Tissue = anno_simple(tissue_vec,
                       col = c("no" = "white", "yes" = "#4DAF4A"),
                       height = unit(5, "mm"),
                       border = TRUE),
  Urine = anno_simple(urine_vec,
                      col = c("no" = "white", "yes" = "#FF7F00"),
                      height = unit(5, "mm"),
                      border = TRUE),
  annotation_name_side = "left",
  annotation_name_gp = gpar(fontsize = 8)
)

cat("\n=== Column Annotations Created ===\n")
```

# Create the OncoPrint-style plot

```{r, fig.width=16, fig.height=12, eval=TRUE}
# Calculate protein frequency percentage
protein_freq <- rowSums(protein_matrix[rownames(heatmap_matrix_ordered), ] > 0)
protein_pct <- round((protein_freq / ncol(protein_matrix)) * 100, 1)

# Create row annotation with barplot showing percentage
row_ha_right <- rowAnnotation(
  `Frequency %` = anno_barplot(protein_pct,
                                gp = gpar(fill = "#4DAF4A"),
                                border = FALSE,
                                bar_width = 0.8,
                                axis_param = list(side = "top",
                                                  labels_rot = 0,
                                                  gp = gpar(fontsize = 8)),
                                width = unit(3, "cm"))
)

# Calculate column split positions to add gaps between sample types
# Find where Plasma ends and Tissue starts, and where Tissue ends and Urine starts
sample_categories_ordered <- col_order_df$SampleCategory

# Find the last position of each category
plasma_end <- max(which(sample_categories_ordered == "Plasma"))
tissue_end <- max(which(sample_categories_ordered == "Tissue"))

# Create column splits vector
column_splits <- rep("Other", ncol(heatmap_matrix_ordered))
column_splits[1:plasma_end] <- "Plasma"
if (tissue_end > plasma_end) {
  column_splits[(plasma_end + 1):tissue_end] <- "Tissue"
}
if (tissue_end < ncol(heatmap_matrix_ordered)) {
  # Check if there are Urine samples
  urine_exists <- any(sample_categories_ordered == "Urine")
  if (urine_exists) {
    urine_start <- min(which(sample_categories_ordered == "Urine"))
    urine_end <- max(which(sample_categories_ordered == "Urine"))
    column_splits[urine_start:urine_end] <- "Urine"
  }
}

cat("\n=== Column Split Summary ===\n")
cat(paste("Plasma studies: 1 -", plasma_end, "\n"))
cat(paste("Tissue studies:", plasma_end + 1, "-", tissue_end, "\n"))
if (any(sample_categories_ordered == "Urine")) {
  urine_start <- min(which(sample_categories_ordered == "Urine"))
  urine_end <- max(which(sample_categories_ordered == "Urine"))
  cat(paste("Urine studies:", urine_start, "-", urine_end, "\n"))
}

# Create the oncoPrint with column splits and bigger gaps
onco_plot <- oncoPrint(heatmap_matrix_ordered,
          alter_fun = alter_fun_list,
          col = col,
          column_title = "Protein Biomarkers by Study (Triangle: ◣ Predictive, ◥ Prognostic)",
          remove_empty_columns = FALSE,
          show_column_names = TRUE,
          column_names_gp = gpar(fontsize = 6),
          row_names_gp = gpar(fontsize = 8),
          row_names_side = "right",
          right_annotation = row_ha_right,
          row_order = 1:nrow(heatmap_matrix_ordered),
          column_order = 1:ncol(heatmap_matrix_ordered),
          column_split = column_splits,
          column_gap = unit(5, "mm"),
          top_annotation = column_ha)

print(onco_plot)
cat("\n=== OncoPrint Created Successfully ===\n")
```

# Save outputs

```{r}
# Save reordered study table
protein_table_reordered <- protein_table[column_order, ]
protein_table_reordered$New_Study_Number <- 1:nrow(protein_table_reordered)
protein_table_reordered$Original_Study_Number <- column_order

# Reorder columns
protein_table_reordered <- protein_table_reordered[, c("New_Study_Number", "Original_Study_Number",
                                                       setdiff(names(protein_table_reordered),
                                                              c("New_Study_Number", "Original_Study_Number")))]

# Save the reordered table
write_xlsx(protein_table_reordered,
           file.path(wd$outData, "Protein_Biomarker_Studies_REORDERED.xlsx"))

cat("\n=== Reordered study table saved ===\n")
cat(paste("Location:", file.path(wd$outData, "Protein_Biomarker_Studies_REORDERED.xlsx"), "\n"))

# Save study mapping
write_xlsx(study_mapping,
           file.path(wd$outData, "Protein_Study_Number_Mapping.xlsx"))

cat(paste("Study mapping saved to:", file.path(wd$outData, "Protein_Study_Number_Mapping.xlsx"), "\n"))

# Save plots as PDF
pdf(file.path(wd$outCurr, "Protein_Biomarker_OncoPrint.pdf"),
    width = 16, height = 18)
print(onco_plot)
dev.off()

# Save as PNG
png(file.path(wd$outCurr, "Protein_Biomarker_OncoPrint.png"),
    width = 16, height = 12, units = "in", res = 300)
print(onco_plot)
dev.off()

cat("\n=== Plots saved successfully ===\n")
cat(paste("PDF:", file.path(wd$outCurr, "Protein_Biomarker_OncoPrint.pdf"), "\n"))
cat(paste("PNG:", file.path(wd$outCurr, "Protein_Biomarker_OncoPrint.png"), "\n"))
```

# Simple Binary Heatmap (Presence/Absence)

This section creates a simpler heatmap showing only protein presence (black) vs absence (white), without distinguishing between prognostic and predictive studies.

```{r, fig.width=16, fig.height=12}
# Use the ordered protein matrix (same ordering as OncoPrint)
binary_matrix <- protein_matrix[rownames(heatmap_matrix_ordered), column_order]

# Rename columns to match new study numbers
colnames(binary_matrix) <- as.character(1:ncol(binary_matrix))

# Convert to numeric matrix (0 = white/absent, 1 = black/present)
binary_matrix_numeric <- apply(binary_matrix, c(1, 2), as.numeric)

# Recalculate protein frequency for row annotation
protein_freq_binary <- rowSums(binary_matrix_numeric)
protein_pct_binary <- round((protein_freq_binary / ncol(binary_matrix_numeric)) * 100, 1)

# Create row annotation with barplot for RIGHT side
row_ha_binary_right <- rowAnnotation(
  `Frequency %` = anno_barplot(protein_pct_binary,
                                gp = gpar(fill = "grey50"),
                                border = FALSE,
                                bar_width = 0.8,
                                axis_param = list(side = "top",
                                                  labels_rot = 0,
                                                  gp = gpar(fontsize = 8)),
                                width = unit(3, "cm"))
)

# Create row annotation with text for LEFT side (just the percentage numbers)
# Use anno_empty with custom drawing function
row_ha_binary_left <- rowAnnotation(
  `Freq %` = anno_empty(border = FALSE, width = unit(2.5, "cm")),
  annotation_name_side = "top",
  annotation_name_gp = gpar(fontsize = 8)
)

# Draw the text using decorate_annotation
# This will be done after drawing the heatmap

# Use the same column annotations and column splits as before (Plasma, Tissue, Urine)
# Create simple binary heatmap with ComplexHeatmap and bigger gaps
simple_heatmap <- Heatmap(
  binary_matrix_numeric,
  name = "Protein",
  col = c("0" = "white", "1" = "firebrick3"),

  # Column settings
  column_title = "Protein Biomarkers by Study (Simple Binary)",
  show_column_names = TRUE,
  column_names_gp = gpar(fontsize = 6),
  cluster_columns = FALSE,
  column_order = 1:ncol(binary_matrix_numeric),
  column_split = column_splits,
  column_gap = unit(5, "mm"),
  top_annotation = column_ha,

  # Row settings
  show_row_names = TRUE,
  row_names_gp = gpar(fontsize = 8),
  row_names_side = "right",
  cluster_rows = FALSE,
  row_order = 1:nrow(binary_matrix_numeric),
  left_annotation = row_ha_binary_left,
  right_annotation = row_ha_binary_right,

  # Heatmap settings
  rect_gp = gpar(col = "grey90", lwd = 0.5),
  border = TRUE,

  # Legend settings
  show_heatmap_legend = TRUE,
  heatmap_legend_param = list(
    title = "Protein Status",
    at = c(0, 1),
    labels = c("Absent", "Present"),
    legend_gp = gpar(fill = c("white", "black"))
  )
)

# Draw the heatmap
draw(simple_heatmap)

# Add percentage text to the left annotation
decorate_annotation("Freq %", {
  n = length(protein_pct_binary)
  for(i in 1:n) {
    grid.text(sprintf("%.0f%%", protein_pct_binary[i]),
              x = unit(0.9, "npc"),
              y = unit(1 - (i - 0.5)/n, "npc"),
              gp = gpar(fontsize = 7),
              just = "right")
  }
})

cat("\n=== Simple Binary Heatmap Created Successfully ===\n")
```

# Save Simple Binary Heatmap

```{r}
# Save as PDF
pdf(file.path(wd$outCurr, "Protein_Biomarker_Simple_Heatmap.pdf"),
    width = 16, height = 30)
draw(simple_heatmap)
# Add percentage text to the left annotation
decorate_annotation("Freq %", {
  n = length(protein_pct_binary)
  for(i in 1:n) {
    grid.text(sprintf("%.0f%%", protein_pct_binary[i]),
              x = unit(0.9, "npc"),
              y = unit(1 - (i - 0.5)/n, "npc"),
              gp = gpar(fontsize = 7),
              just = "right")
  }
})
dev.off()

# Save as PNG
png(file.path(wd$outCurr, "Protein_Biomarker_Simple_Heatmap.png"),
    width = 16, height = 18, units = "in", res = 300)
draw(simple_heatmap)
# Add percentage text to the left annotation
decorate_annotation("Freq %", {
  n = length(protein_pct_binary)
  for(i in 1:n) {
    grid.text(sprintf("%.0f%%", protein_pct_binary[i]),
              x = unit(0.9, "npc"),
              y = unit(1 - (i - 0.5)/n, "npc"),
              gp = gpar(fontsize = 7),
              just = "right")
  }
})
dev.off()

cat("\n=== Simple heatmap saved successfully ===\n")
cat(paste("PDF:", file.path(wd$outCurr, "Protein_Biomarker_Simple_Heatmap.pdf"), "\n"))
cat(paste("PNG:", file.path(wd$outCurr, "Protein_Biomarker_Simple_Heatmap.png"), "\n"))
```

# Session Info

```{r}
sessionInfo()
```
